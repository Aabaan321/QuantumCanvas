<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>NebulaTouch v4: Refined Core</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', Courier, monospace; }
        canvas { display: block; }
        
        /* MINIMAL UI */
        #ui-layer {
            position: absolute; top: 20px; left: 20px;
            pointer-events: none;
            color: rgba(255, 255, 255, 0.7);
            z-index: 10;
        }
        h1 { margin: 0; font-size: 1rem; letter-spacing: 3px; color: #00ffcc; text-shadow: 0 0 10px rgba(0,255,204,0.5); }
        p { font-size: 0.8rem; margin: 5px 0; }
        
        #status-text {
            position: absolute; bottom: 30px; left: 50%;
            transform: translateX(-50%);
            color: #fff; font-size: 1.2rem;
            text-shadow: 0 0 10px #00ffcc;
            opacity: 0.8;
            pointer-events: none;
        }

        /* START BUTTON OVERLAY */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 100;
        }
        button {
            background: transparent; border: 1px solid #00ffcc; color: #00ffcc;
            padding: 15px 30px; font-size: 1rem; cursor: pointer;
            font-family: inherit; letter-spacing: 2px;
            transition: 0.3s;
        }
        button:hover { background: #00ffcc; color: #000; box-shadow: 0 0 20px #00ffcc; }
        
        #video-input { display: none; }
    </style>
</head>
<body>

    <div id="start-screen">
        <h1 style="font-size: 2rem; margin-bottom: 20px;">NEBULA TOUCH v4</h1>
        <p style="color: #aaa; margin-bottom: 30px;">Microphone & Camera Required</p>
        <button onclick="startSystem()">ACTIVATE SYSTEM</button>
    </div>

    <div id="ui-layer">
        <h1>GESTURE OS</h1>
        <p>State: <span id="state-log">Ready</span></p>
        <p>Mic: <span id="mic-log">Inactive</span></p>
        <div style="margin-top: 15px; font-size: 0.7rem; opacity: 0.5;">
            [1 Hand] Rotate / Fist (Chaos) / Point (Trail)<br>
            [2 Hands] Clap (BlackHole) / Stretch (Warp)<br>
            [Voice] Speak to Pulse
        </div>
    </div>

    <div id="status-text">WAITING FOR INPUT</div>

    <video id="video-input" playsinline></video>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

    <script>
        // --- SETUP ---
        const CONFIG = {
            count: 7000, // Slightly fewer for cleaner look
            particleSize: 0.15, // THIN and elegant
            camZ: 35
        };

        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.z = CONFIG.camZ;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // --- AUDIO SYSTEM (Hidden but Functional) ---
        let analyser, dataArray;
        let audioFactor = 0;
        
        async function initAudio() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioCtx.createMediaStreamSource(stream);
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = 64;
                source.connect(analyser);
                dataArray = new Uint8Array(analyser.frequencyBinCount);
                document.getElementById('mic-log').innerText = "Listening...";
            } catch (e) {
                console.log("Audio disabled");
            }
        }

        // --- PARTICLE SYSTEM (Clean Style) ---
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(CONFIG.count * 3);
        const targetPositions = new Float32Array(CONFIG.count * 3);
        const colors = new Float32Array(CONFIG.count * 3);
        const originalColors = new Float32Array(CONFIG.count * 3);

        // Init: Galaxy Disc
        for(let i=0; i<CONFIG.count; i++) {
            const idx = i*3;
            // Spiral Galaxy Logic
            const r = Math.random() * 15;
            const theta = i * 0.1 + (r * 0.5);
            positions[idx] = r * Math.cos(theta);
            positions[idx+1] = (Math.random()-0.5) * (r * 0.2); // Thin disc
            positions[idx+2] = r * Math.sin(theta);
            
            targetPositions[idx] = positions[idx];
            targetPositions[idx+1] = positions[idx+1];
            targetPositions[idx+2] = positions[idx+2];

            // Color: Cyan/Blue Mix
            colors[idx] = 0.1; colors[idx+1] = 0.8; colors[idx+2] = 1.0;
            if(Math.random()>0.8) { colors[idx]=1; colors[idx+1]=1; colors[idx+2]=1; } // White stars
            
            originalColors[idx] = colors[idx];
            originalColors[idx+1] = colors[idx+1];
            originalColors[idx+2] = colors[idx+2];
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        // Use standard PointsMaterial (Cleaner than shader)
        const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');
        const material = new THREE.PointsMaterial({
            size: CONFIG.particleSize,
            map: sprite,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            transparent: true,
            opacity: 0.8
        });

        const particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);

        // --- TRAIL SYSTEM (Thinner) ---
        const trailGeo = new THREE.BufferGeometry();
        const trailPos = new Float32Array(100 * 3).fill(0);
        trailGeo.setAttribute('position', new THREE.BufferAttribute(trailPos, 3));
        // Thinner line, less opacity
        const trailMat = new THREE.LineBasicMaterial({ color: 0x00ffcc, opacity: 0.3, transparent: true });
        const trailLine = new THREE.Line(trailGeo, trailMat);
        scene.add(trailLine);

        // --- LOGIC ---
        const state = {
            hands: [],
            mode: 'IDLE',
            smoothHand: {x:0, y:0}
        };

        function startSystem() {
            document.getElementById('start-screen').style.display = 'none';
            initAudio();
            initCamera();
            animate();
        }

        // --- HAND TRACKING ---
        function onResults(results) {
            state.hands = [];
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                document.getElementById('state-log').innerText = "Tracking " + results.multiHandLandmarks.length + " Hand(s)";
                
                for (const lm of results.multiHandLandmarks) {
                    // Map Coordinates
                    const x = (lm[8].x - 0.5) * -40;
                    const y = (lm[8].y - 0.5) * -30;
                    
                    // Simple Fist Detection
                    const d = Math.hypot(lm[8].x - lm[0].x, lm[8].y - lm[0].y);
                    const isFist = d < 0.3; // Normalized coord distance

                    // Index Finger Pointing? (Tip above knuckle)
                    const isPointing = !isFist && lm[8].y < lm[6].y;

                    state.hands.push({ x, y, isFist, isPointing });
                }
            } else {
                document.getElementById('state-log').innerText = "Searching...";
            }
        }

        function initCamera() {
            const video = document.getElementById('video-input');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 2, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
            hands.onResults(onResults);
            
            const camera = new Camera(video, {
                onFrame: async () => { await hands.send({image: video}); },
                width: 640, height: 480
            });
            camera.start();
        }

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            // 1. Process Audio
            if (analyser) {
                analyser.getByteFrequencyData(dataArray);
                let sum = 0;
                for(let i=0; i<dataArray.length; i++) sum += dataArray[i];
                // Smooth audio factor
                const targetFactor = sum / dataArray.length / 255; 
                audioFactor += (targetFactor - audioFactor) * 0.1;
            }

            // Audio Visuals (Subtle pulse)
            material.size = CONFIG.particleSize + (audioFactor * 0.2); // Only slightly get bigger

            // 2. Gesture Logic
            let rotX = 0, rotY = 0;
            let explosion = 0;
            let stretch = 1;
            let gravity = null;

            if (state.hands.length === 1) {
                const h = state.hands[0];
                state.smoothHand.x += (h.x - state.smoothHand.x) * 0.1;
                state.smoothHand.y += (h.y - state.smoothHand.y) * 0.1;

                rotY = state.smoothHand.x * 0.002;
                rotX = state.smoothHand.y * 0.002;

                if (h.isFist) {
                    document.getElementById('status-text').innerText = "CHAOS MODE";
                    explosion = 2; // Chaos magnitude
                } else if (h.isPointing) {
                    document.getElementById('status-text').innerText = "DRAWING TRAIL";
                    // Update Trail
                    const posAttr = trailLine.geometry.attributes.position;
                    const arr = posAttr.array;
                    // Shift values down
                    for(let i=299; i>=3; i--) arr[i] = arr[i-3];
                    arr[0] = h.x; arr[1] = h.y; arr[2] = 5;
                    posAttr.needsUpdate = true;
                } else {
                    document.getElementById('status-text').innerText = "ROTATING";
                }

            } else if (state.hands.length === 2) {
                const h1 = state.hands[0];
                const h2 = state.hands[1];
                const dist = Math.hypot(h1.x - h2.x, h1.y - h2.y);

                if (dist < 8) {
                    document.getElementById('status-text').innerText = "BLACK HOLE";
                    gravity = { x: (h1.x+h2.x)/2, y: (h1.y+h2.y)/2 };
                } else if (dist > 15) {
                    document.getElementById('status-text').innerText = "WARPING SPACE";
                    stretch = 1 + (dist-15)*0.05;
                } else {
                    document.getElementById('status-text').innerText = "DUAL HANDS DETECTED";
                }
            } else {
                // IDLE
                document.getElementById('status-text').innerText = "";
                rotY = 0.002; // Auto spin
            }

            // Apply Rotation
            particleSystem.rotation.y += rotY;
            particleSystem.rotation.x -= rotX;

            // 3. Physics Update
            const pos = geometry.attributes.position.array;
            const target = geometry.attributes.target.array;
            const col = geometry.attributes.color.array;

            for(let i=0; i<CONFIG.count; i++) {
                const idx = i*3;
                let tx = target[idx];
                let ty = target[idx+1];
                let tz = target[idx+2];

                // Modifiers
                if (stretch !== 1) { tx *= stretch; ty *= stretch; tz *= stretch; }
                
                if (gravity) {
                    // Pull towards center
                    tx = tx * 0.9 + gravity.x * 0.1;
                    ty = ty * 0.9 + gravity.y * 0.1;
                    tz = tz * 0.9;
                }

                if (explosion > 0) {
                    tx += (Math.random()-0.5) * explosion * 10;
                    ty += (Math.random()-0.5) * explosion * 10;
                    tz += (Math.random()-0.5) * explosion * 10;
                }

                // Audio Color Pulse (Subtle)
                if (audioFactor > 0.4 && i % 20 === 0) {
                    col[idx] = 1; col[idx+1] = 0; col[idx+2] = 0.5; // Pink accents on beat
                } else {
                    // Return to original
                    col[idx] += (originalColors[idx] - col[idx]) * 0.05;
                    col[idx+1] += (originalColors[idx+1] - col[idx+1]) * 0.05;
                    col[idx+2] += (originalColors[idx+2] - col[idx+2]) * 0.05;
                }

                // Lerp Position
                pos[idx] += (tx - pos[idx]) * 0.08;
                pos[idx+1] += (ty - pos[idx+1]) * 0.08;
                pos[idx+2] += (tz - pos[idx+2]) * 0.08;
            }

            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;

            renderer.render(scene, camera);
        }

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
