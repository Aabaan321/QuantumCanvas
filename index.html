<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>NebulaTouch Ultimate</title>

<style>
body{
margin:0;
overflow:hidden;
background:black;
font-family:Arial;
}

#status{
position:absolute;
top:15px;
left:15px;
color:#00ffc8;
background:rgba(0,0,0,0.5);
padding:10px;
border-radius:10px;
}
video{display:none;}
</style>

</head>

<body>

<div id="status">Status: Idle</div>
<video id="video" playsinline></video>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>

// ======================
// CONFIG
// ======================

const CONFIG = {
particleCount:6000,
camZ:40,
swipeThreshold:0.5,
motionThreshold:0.1,
gestureHoldFrames:10,
pinchThreshold:0.05
};

// ======================
// STATE
// ======================

const state={
hand:{x:0,y:0},
lastX:0,
velocity:0,
autoRotate:false,
freeze:false,
gravity:false,
cooldown:0,
gestureBuffer:null,
gestureCounter:0,
shapeIndex:0
};

// ======================
// THREE.JS SETUP
// ======================

const scene=new THREE.Scene();

const camera=new THREE.PerspectiveCamera(
75,
window.innerWidth/window.innerHeight,
0.1,
1000
);

camera.position.z=CONFIG.camZ;

const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth,window.innerHeight);
document.body.appendChild(renderer.domElement);

// ======================
// PARTICLES
// ======================

const geometry=new THREE.BufferGeometry();

const positions=new Float32Array(CONFIG.particleCount*3);
const target=new Float32Array(CONFIG.particleCount*3);

for(let i=0;i<positions.length;i++){
positions[i]=(Math.random()-0.5)*80;
target[i]=positions[i];
}

geometry.setAttribute('position',new THREE.BufferAttribute(positions,3));

const material=new THREE.PointsMaterial({
size:0.4,
color:0x00ffff,
blending:THREE.AdditiveBlending,
transparent:true,
depthWrite:false
});

const particleSystem=new THREE.Points(geometry,material);
scene.add(particleSystem);

// ======================
// SHAPES
// ======================

const shapes={

sphere:(i)=>{
const r=12;
const theta=Math.random()*Math.PI*2;
const phi=Math.acos(2*Math.random()-1);
return[
r*Math.sin(phi)*Math.cos(theta),
r*Math.sin(phi)*Math.sin(theta),
r*Math.cos(phi)
];
},

cube:()=>{
const s=15;
return[
(Math.random()-0.5)*s*2,
(Math.random()-0.5)*s*2,
(Math.random()-0.5)*s*2
];
}

};

const shapeKeys=Object.keys(shapes);

function morph(name){

const fn=shapes[name];

for(let i=0;i<CONFIG.particleCount;i++){
const p=fn(i);
target[i*3]=p[0];
target[i*3+1]=p[1];
target[i*3+2]=p[2];
}

}

// initial
morph("sphere");

// ======================
// GESTURE DETECTION
// ======================

function detectGesture(lm){

const up=(tip,mcp)=>lm[tip].y<lm[mcp].y;

const idx=up(8,5);
const mid=up(12,9);
const ring=up(16,13);
const pinky=up(20,17);

if(idx && mid && !ring && !pinky) return "peace";
if(idx && !mid && !ring && !pinky) return "point";
if(!idx && !mid && !ring && !pinky) return "fist";
if(idx && mid && ring && pinky) return "open";

return null;
}

// ======================
// COMMAND EXECUTION
// ======================

function executeCommand(g){

if(g==="peace"){
state.autoRotate=!state.autoRotate;
}

if(g==="fist"){
state.freeze=!state.freeze;
}

if(g==="open"){
state.gravity=!state.gravity;
}

}

// ======================
// MEDIAPIPE
// ======================

const video=document.getElementById("video");

const hands=new Hands({
locateFile:(file)=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
});

hands.setOptions({
maxNumHands:1,
modelComplexity:1,
minDetectionConfidence:0.6,
minTrackingConfidence:0.6
});

hands.onResults(onResults);

const cam=new Camera(video,{
onFrame:async()=>{
await hands.send({image:video});
},
width:640,
height:480
});

cam.start();

// ======================
// MAIN INPUT LOGIC
// ======================

function onResults(res){

const handsLm=res.multiHandLandmarks;

if(!handsLm) return;

const lm=handsLm[0];

const x=(lm[8].x-0.5)*-40;
const dx=x-state.lastX;
state.velocity=dx;
state.lastX=x;

if(state.cooldown>0) state.cooldown--;

const speed=Math.abs(dx);

if(speed>CONFIG.swipeThreshold){

state.shapeIndex=
(state.shapeIndex+1)%shapeKeys.length;

morph(shapeKeys[state.shapeIndex]);

state.cooldown=20;
state.gestureBuffer=null;

return;
}

const gesture=detectGesture(lm);

if(gesture && gesture===state.gestureBuffer){

state.gestureCounter++;

if(state.gestureCounter>CONFIG.gestureHoldFrames){

executeCommand(gesture);
state.cooldown=20;
state.gestureCounter=0;

}

}else{

state.gestureBuffer=gesture;
state.gestureCounter=0;

}

}

// ======================
// ANIMATION LOOP
// ======================

function animate(){

requestAnimationFrame(animate);

const pos=geometry.attributes.position.array;

for(let i=0;i<CONFIG.particleCount;i++){

const idx=i*3;

if(!state.freeze){

pos[idx]+= (target[idx]-pos[idx])*0.07;
pos[idx+1]+= (target[idx+1]-pos[idx+1])*0.07;
pos[idx+2]+= (target[idx+2]-pos[idx+2])*0.07;

}

}

geometry.attributes.position.needsUpdate=true;

if(state.autoRotate){

particleSystem.rotation.y+=0.005;

}

renderer.render(scene,camera);

}

animate();

</script>
</body>
</html>
