<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>NebulaTouch v4: Cosmic Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@500;700&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }
        
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #000;
            font-family: 'Rajdhani', sans-serif;
        }
        
        canvas { display: block; }
        
        #video-input { 
            position: absolute; top: 0; left: 0; opacity: 0; pointer-events: none; 
        }
        
        /* --- UI CONTAINERS --- */
        .hud-panel {
            position: absolute;
            background: rgba(10, 15, 20, 0.75);
            border: 1px solid rgba(0, 255, 204, 0.3);
            color: #00ffcc;
            padding: 15px;
            border-radius: 12px;
            backdrop-filter: blur(12px);
            box-shadow: 0 0 20px rgba(0, 255, 204, 0.1);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            max-height: 85vh;
            overflow-y: auto;
            cursor: pointer; /* Indicates clickable */
            z-index: 100;
        }

        .hud-panel:hover {
            background: rgba(10, 15, 20, 0.9);
            border-color: rgba(0, 255, 204, 0.6);
        }

        /* Minimize Class (Applied when clicked) */
        .minimized {
            max-height: 50px !important;
            overflow: hidden;
            opacity: 0.6;
            width: auto !important;
        }
        .minimized h2, .minimized h3 { margin: 0; font-size: 1rem; }
        .minimized .content { display: none; }

        /* Left Panel: Instructions */
        #ui-left {
            top: 20px; left: 20px;
            width: 280px;
            transform-origin: top left;
        }

        /* Right Panel: Features */
        #ui-right {
            top: 20px; right: 20px;
            width: 260px;
            text-align: right;
            transform-origin: top right;
        }

        /* Typography */
        h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2rem;
            margin-bottom: 10px;
            color: #fff;
            text-shadow: 0 0 10px #00ffcc;
            pointer-events: none;
        }

        h3 {
            font-family: 'Orbitron', sans-serif;
            color: #ff00cc;
            margin-bottom: 5px;
            font-size: 1rem;
            pointer-events: none;
        }

        .section-header {
            font-size: 0.9rem;
            font-weight: 700;
            color: #fff;
            margin-top: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 2px;
        }

        p { font-size: 0.85rem; margin: 4px 0; color: #aaddcc; }
        
        .key-bind {
            color: #ffcc00;
            font-weight: bold;
            font-family: monospace;
            background: rgba(255, 204, 0, 0.1);
            padding: 0 4px;
            border-radius: 3px;
        }

        /* Feature Status Items */
        .feature-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.8rem;
            margin: 5px 0;
            padding: 4px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.03);
        }
        
        .feature-active { color: #00ff88; text-shadow: 0 0 5px rgba(0, 255, 136, 0.5); border-right: 3px solid #00ff88;}
        .feature-inactive { color: #555; }

        /* Center Feedback */
        #mode-display {
            position: absolute;
            bottom: 30px; left: 50%;
            transform: translateX(-50%);
            text-align: center;
            pointer-events: none;
        }
        #mode-name {
            font-family: 'Orbitron', sans-serif;
            font-size: 2.5rem;
            font-weight: 900;
            background: linear-gradient(to right, #00ffcc, #00ff88);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        #gesture-icon {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 6rem;
            opacity: 0;
            filter: drop-shadow(0 0 20px #00ffcc);
            transition: transform 0.2s, opacity 0.2s;
            pointer-events: none;
            z-index: 50;
        }

        .show-icon { opacity: 1 !important; transform: translate(-50%, -50%) scale(1.2) !important; }

        /* Scrollbars */
        ::-webkit-scrollbar { width: 4px; }
        ::-webkit-scrollbar-track { background: rgba(0,0,0,0.2); }
        ::-webkit-scrollbar-thumb { background: #00ffcc; border-radius: 2px; }

        .click-hint {
            font-size: 0.7rem;
            color: #666;
            margin-top: 10px;
            font-style: italic;
            text-align: center;
        }
    </style>
</head>
<body>

    <div id="ui-left" class="hud-panel" onclick="togglePanel(this)">
        <h1>‚ö° NebulaTouch v4</h1>
        <div class="content">
            <div class="section-header">ONE HAND</div>
            <p><span class="key-bind">‚úåÔ∏è Peace</span> Auto-Rotate</p>
            <p><span class="key-bind">üëç Thumb Up</span> Random Color</p>
            <p><span class="key-bind">üëé Thumb Down</span> Reset</p>
            <p><span class="key-bind">ü§ò Rock</span> Explosion</p>
            <p><span class="key-bind">‚òùÔ∏è Point</span> Speed Up</p>
            
            <div class="section-header">TWO HANDS</div>
            <p><span class="key-bind">üëê Palms</span> Gravity Field</p>
            <p><span class="key-bind">üëè Clap</span> Shockwave</p>
            <p><span class="key-bind">‚ÜîÔ∏è Pull Apart</span> Cosmic Expand</p>
            <p><span class="key-bind">‚úåÔ∏è+‚úåÔ∏è</span> Mirror Mode</p>
            
            <div class="section-header">GESTURES</div>
            <p>ü§è <b>Pinch:</b> Resize / Draw</p>
            <p>üëã <b>Swipe:</b> Next Shape</p>
            
            <div class="click-hint">(Click panel to minimize)</div>
        </div>
    </div>

    <div id="ui-right" class="hud-panel" onclick="togglePanel(this)">
        <h3>‚öôÔ∏è STATUS & TRIGGERS</h3>
        <div class="content">
            <div class="feature-row" id="f-rotate">
                <span>[‚úåÔ∏è Peace]</span> <span>Auto-Rotate ‚≠ï</span>
            </div>
            <div class="feature-row" id="f-gravity">
                <span>[üëê Palms]</span> <span>Gravity ‚≠ï</span>
            </div>
            <div class="feature-row" id="f-mirror">
                <span>[‚úåÔ∏è‚úåÔ∏è Double]</span> <span>Mirror ‚≠ï</span>
            </div>
            <div class="feature-row" id="f-trails">
                <span>[Key: T]</span> <span>Trails ‚≠ï</span>
            </div>
            <div class="feature-row" id="f-freeze">
                <span>[üññ Vulcan]</span> <span>Freeze ‚≠ï</span>
            </div>
            <div class="feature-row" id="f-audio">
                <span>[Key: S]</span> <span>Sound üîä</span>
            </div>
            
            <div style="margin-top: 15px; border-top: 1px solid #333; padding-top: 5px;">
                <p>FPS: <span id="fps" style="color:#fff">60</span></p>
                <p>Hands: <span id="hand-count" style="color:#fff">0</span></p>
            </div>
            <div class="click-hint">(Click panel to minimize)</div>
        </div>
    </div>

    <div id="mode-display">
        <div id="mode-name">SPHERE</div>
    </div>

    <div id="gesture-icon">‚ú®</div>
    
    <canvas id="particle-trail" style="position:absolute; top:0; left:0; pointer-events:none; mix-blend-mode: screen;"></canvas>
    <video id="video-input" playsinline></video>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // --- AUDIO SYSTEM ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playSound(freq, type='sine', len=0.1) {
            if (!state.sound) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.frequency.value = freq;
            osc.type = type;
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + len);
            osc.start();
            osc.stop(audioCtx.currentTime + len);
        }

        // --- STATE & CONFIG ---
        const CONFIG = {
            count: 8000,
            camZ: 45,
            swipeThresh: 0.8,
            pinchThresh: 0.06,
            expansionThresh: 0.15 // Threshold for rapid hand movement
        };

        const state = {
            mode: 'SHAPE',
            shapeIdx: 0,
            hand: {x:0, y:0},
            hand2: {x:0, y:0},
            lastHandDist: 0, // For measuring expansion speed
            velocity: 0,
            lastX: 0,
            
            // Features
            autoRotate: false,
            gravity: false,
            mirror: false,
            freeze: false,
            trails: false,
            sound: true,
            
            // System
            cooldown: 0,
            explosion: false,
            expansion: false, // The new feature
            handsDetected: 0,
            fpsTime: Date.now()
        };

        // --- THREE.JS SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.z = CONFIG.camZ;

        const renderer = new THREE.WebGLRenderer({antialias: true, alpha: true});
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // Lights
        const light = new THREE.PointLight(0x00ffcc, 1, 100);
        light.position.set(10, 10, 10);
        scene.add(light);
        scene.add(new THREE.AmbientLight(0x404040));

        // --- PARTICLES ---
        const geo = new THREE.BufferGeometry();
        const pos = new Float32Array(CONFIG.count * 3);
        const target = new Float32Array(CONFIG.count * 3);
        const vels = new Float32Array(CONFIG.count * 3); // Velocities
        const cols = new Float32Array(CONFIG.count * 3);

        for(let i=0; i<CONFIG.count; i++) {
            pos[i*3] = (Math.random()-0.5)*100;
            pos[i*3+1] = (Math.random()-0.5)*100;
            pos[i*3+2] = (Math.random()-0.5)*100;
            cols[i*3] = 1; cols[i*3+1] = 1; cols[i*3+2] = 1;
        }

        geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
        geo.setAttribute('color', new THREE.BufferAttribute(cols, 3));
        const mat = new THREE.PointsMaterial({
            size: 0.35, vertexColors: true, blending: THREE.AdditiveBlending,
            transparent: true, opacity: 0.8
        });
        const particles = new THREE.Points(geo, mat);
        scene.add(particles);

        // --- SHAPES MATH ---
        const shapes = {
            'sphere': i => {
                const r=12, t=Math.random()*6.28, p=Math.acos(2*Math.random()-1);
                return [r*Math.sin(p)*Math.cos(t), r*Math.sin(p)*Math.sin(t), r*Math.cos(p)];
            },
            'cube': i => {
                const s=16, ax=Math.floor(Math.random()*3);
                const c=[(Math.random()-.5)*s, (Math.random()-.5)*s, (Math.random()-.5)*s];
                c[ax] = (Math.random()>.5 ? .5 : -.5) * s;
                return c;
            },
            'galaxy': i => {
                const arm=i%3, t=Math.random()*10, r=t*2;
                const a = (arm/3)*6.28;
                return [r*Math.cos(t+a), (Math.random()-.5)*4, r*Math.sin(t+a)];
            },
            'heart': i => {
                 const t=Math.random()*6.28, s=0.8;
                 return [16*Math.pow(Math.sin(t),3)*s, (13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t))*s, (Math.random()-.5)*5];
            },
            'ring': i => {
                const t=Math.random()*6.28, r=14, r2=(Math.random()-.5)*4;
                return [(r+r2)*Math.cos(t), (r+r2)*Math.sin(t), (Math.random()-.5)*2];
            }
        };
        const shapeKeys = Object.keys(shapes);

        function setShape(name) {
            const fn = shapes[name];
            for(let i=0; i<CONFIG.count; i++) {
                const [x,y,z] = fn(i);
                target[i*3] = x; target[i*3+1] = y; target[i*3+2] = z;
                // Reset colors to cyan/blue theme
                cols[i*3] = 0.1; cols[i*3+1] = 0.8; cols[i*3+2] = 1.0; 
            }
            geo.attributes.color.needsUpdate = true;
            document.getElementById('mode-name').innerText = name.toUpperCase();
            playSound(400, 'sine');
        }

        // --- SPECIAL FX ---
        function triggerCosmicExpansion() {
            // The "Big Bang" effect - user starts close and pulls away
            state.expansion = true;
            showIcon('üí•');
            playSound(100, 'sawtooth', 0.5);
            
            for(let i=0; i<CONFIG.count; i++) {
                const idx = i*3;
                // Explode outwards from center
                const dx = pos[idx];
                const dy = pos[idx+1];
                const dz = pos[idx+2];
                const len = Math.sqrt(dx*dx + dy*dy + dz*dz) + 0.1;
                
                // Add massive velocity outwards
                vels[idx] = (dx/len) * 4; 
                vels[idx+1] = (dy/len) * 4; 
                vels[idx+2] = (dz/len) * 4;

                // Turn colors to fire (Red/Orange)
                cols[idx] = 1.0; cols[idx+1] = Math.random()*0.5; cols[idx+2] = 0;
            }
            geo.attributes.color.needsUpdate = true;

            // Reset after 2 seconds
            setTimeout(() => {
                state.expansion = false;
                setShape(shapeKeys[state.shapeIdx]); // Return to shape
            }, 1500);
        }

        function triggerGravity(active) {
            state.gravity = active;
            updateStatus('gravity', active);
            showIcon(active ? 'üåå' : '‚≠ï');
        }

        // --- UI LOGIC ---
        function togglePanel(el) {
            el.classList.toggle('minimized');
        }

        function updateStatus(id, active) {
            const el = document.getElementById('f-'+id);
            if(el) {
                if(active) {
                    el.classList.add('feature-active');
                    el.classList.remove('feature-inactive');
                } else {
                    el.classList.add('feature-inactive');
                    el.classList.remove('feature-active');
                }
            }
        }

        function showIcon(char) {
            const el = document.getElementById('gesture-icon');
            el.innerText = char;
            el.classList.add('show-icon');
            setTimeout(() => el.classList.remove('show-icon'), 600);
        }

        // --- GESTURE ENGINE ---
        function getDist(p1, p2) {
            return Math.sqrt(Math.pow(p1.x-p2.x, 2) + Math.pow(p1.y-p2.y, 2));
        }

        function onResults(res) {
            state.handsDetected = res.multiHandLandmarks ? res.multiHandLandmarks.length : 0;
            document.getElementById('hand-count').innerText = state.handsDetected;

            if(state.handsDetected > 0) {
                const lm = res.multiHandLandmarks[0];
                const idx = lm[8], thumb = lm[4];
                
                // Track Hand 1 Velocity
                const x = (idx.x - 0.5) * -50;
                const y = (idx.y - 0.5) * -40;
                state.velocity = x - state.lastX;
                state.lastX = x;
                state.hand.x = x; state.hand.y = y;

                // 1. One Hand Swipe (Change Shape)
                if (state.cooldown <= 0 && !state.expansion) {
                    if (state.velocity > CONFIG.swipeThresh) {
                        state.shapeIdx = (state.shapeIdx + 1) % shapeKeys.length;
                        setShape(shapeKeys[state.shapeIdx]);
                        state.cooldown = 20;
                        showIcon('‚û°Ô∏è');
                    }
                }

                // 2. Gesture Detection
                const pinch = getDist(idx, thumb) < CONFIG.pinchThresh;
                const isPeace = lm[8].y < lm[6].y && lm[12].y < lm[10].y && lm[16].y > lm[14].y;
                const isOpen = lm[8].y < lm[6].y && lm[12].y < lm[10].y && lm[16].y < lm[14].y && lm[20].y < lm[18].y;
                const isFist = !isOpen && !isPeace;
                const isVulcan = isOpen && (Math.abs(lm[12].x - lm[16].x) > 0.08); // Simple vulcan check

                if(state.cooldown <= 0) {
                     if(isPeace && state.handsDetected === 1) {
                         state.autoRotate = !state.autoRotate;
                         updateStatus('rotate', state.autoRotate);
                         state.cooldown = 30;
                     } else if (isVulcan) {
                         state.freeze = !state.freeze;
                         updateStatus('freeze', state.freeze);
                         state.cooldown = 30;
                     }
                }

                // 3. Two Hand Logic
                if (state.handsDetected === 2) {
                    const lm2 = res.multiHandLandmarks[1];
                    const idx2 = lm2[8];
                    
                    const h1 = {x: lm[8].x, y: lm[8].y};
                    const h2 = {x: lm2[8].x, y: lm2[8].y};
                    
                    const currentDist = getDist(h1, h2);
                    
                    // NEW: Dynamic Expansion Gesture
                    // Check change in distance
                    const distChange = currentDist - state.lastHandDist;
                    
                    // If moving apart FAST and hands were previously close
                    if (state.cooldown <= 0 && distChange > 0.08 && state.lastHandDist < 0.2) {
                        triggerCosmicExpansion();
                        state.cooldown = 40;
                    }
                    
                    // Gravity (Open Palms Both)
                    if (isOpen && state.cooldown <= 0) {
                        // Check if hand 2 is also roughly open (simplified)
                        if (lm2[8].y < lm2[6].y) {
                            state.gravity = !state.gravity;
                            triggerGravity(state.gravity);
                            state.cooldown = 40;
                        }
                    }

                    // Mirror Mode (Double Peace)
                    if (isPeace && state.cooldown <= 0) {
                        // Simplified check for second hand
                        if (lm2[8].y < lm2[6].y && lm2[16].y > lm2[14].y) { 
                             state.mirror = !state.mirror;
                             updateStatus('mirror', state.mirror);
                             showIcon(state.mirror ? 'ü™û' : '‚≠ï');
                             state.cooldown = 40;
                        }
                    }

                    state.lastHandDist = currentDist;
                } else {
                    state.lastHandDist = 0.5; // Reset default
                }

                if (state.cooldown > 0) state.cooldown--;
            }
        }

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            
            // FPS Calc
            const now = Date.now();
            if(now - state.fpsTime > 500) {
                state.fpsTime = now;
                document.getElementById('fps').innerText = Math.round(1000/(now - state.lastFrame || 16));
            }
            state.lastFrame = now;

            if(!state.freeze) {
                const pa = geo.attributes.position.array;
                
                for(let i=0; i<CONFIG.count; i++) {
                    const idx = i*3;

                    // Physics & Velocities
                    if(state.expansion) {
                        // Apply explosive velocity
                        pa[idx] += vels[idx];
                        pa[idx+1] += vels[idx+1];
                        pa[idx+2] += vels[idx+2];
                        vels[idx] *= 0.95; // Drag
                    } 
                    else if (state.gravity && state.handsDetected > 0) {
                        // Gravity pull to hand
                        const dx = state.hand.x - pa[idx];
                        const dy = state.hand.y - pa[idx+1];
                        const d = Math.sqrt(dx*dx+dy*dy) + 0.1;
                        pa[idx] += dx * 0.05 / d;
                        pa[idx+1] += dy * 0.05 / d;
                    } 
                    else {
                        // Normal Shape Morph
                        const tx = target[idx], ty = target[idx+1], tz = target[idx+2];
                        pa[idx] += (tx - pa[idx]) * 0.08;
                        pa[idx+1] += (ty - pa[idx+1]) * 0.08;
                        pa[idx+2] += (tz - pa[idx+2]) * 0.08;
                    }

                    // Mirror Logic
                    if(state.mirror) pa[idx] = Math.abs(pa[idx]);
                }
                geo.attributes.position.needsUpdate = true;
            }

            // Camera/Group Rotation
            if(state.autoRotate) {
                particles.rotation.y += 0.01;
            } else {
                particles.rotation.y += (state.hand.x * 0.001 - particles.rotation.y) * 0.1;
                particles.rotation.x += (-state.hand.y * 0.001 - particles.rotation.x) * 0.1;
            }

            // Button Floating
            const t = Date.now()*0.001;
            light.position.x = Math.sin(t)*20;
            
            renderer.render(scene, camera);
        }

        // --- INIT ---
        setShape('sphere');
        const vid = document.getElementById('video-input');
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
        hands.onResults(onResults);
        
        const cam = new Camera(vid, {
            onFrame: async () => { await hands.send({image: vid}); },
            width: 640, height: 480
        });
        cam.start();
        animate();

        // Keyboard Binds
        window.addEventListener('keydown', e => {
            if(e.key.toLowerCase() === 't') { state.trails = !state.trails; updateStatus('trails', state.trails); }
            if(e.key.toLowerCase() === 's') { state.sound = !state.sound; updateStatus('audio', state.sound); }
        });
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
