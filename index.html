<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>NebulaTouch v3.1: Stabilized Core</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body { 
            margin: 0; 
            overflow: hidden; 
            background: radial-gradient(ellipse at center, #050510 0%, #000000 100%);
            font-family: 'Orbitron', 'Courier New', monospace;
        }
        
        canvas { display: block; }
        
        #video-input { 
            position: absolute; top: 0; left: 0; opacity: 0; pointer-events: none; 
        }
        
        /* --- UI CLEANUP: Reduced Opacity & Brightness --- */
        #ui {
            position: absolute;
            top: 20px; left: 20px;
            color: #00ffcc;
            pointer-events: none;
            z-index: 10;
            /* Made background darker and more transparent */
            background: linear-gradient(135deg, rgba(0, 10, 20, 0.6) 0%, rgba(0, 5, 10, 0.5) 100%);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(0, 255, 204, 0.1);
            backdrop-filter: blur(8px); /* Reduced blur for performance */
            max-height: 90vh;
            overflow-y: auto;
            transition: opacity 0.3s ease;
        }

        /* Scrollbar cleanup */
        #ui::-webkit-scrollbar { width: 4px; }
        #ui::-webkit-scrollbar-thumb { background: #008866; border-radius: 4px; }
        
        h1 { 
            margin: 0 0 10px 0; 
            font-size: 1.2rem; /* Slightly smaller */
            text-transform: uppercase; 
            letter-spacing: 2px; 
            color: #00ffcc;
            text-shadow: 0 0 10px rgba(0, 255, 204, 0.3);
        }
        
        p { font-size: 0.8rem; margin: 6px 0; opacity: 0.8; line-height: 1.4; }
        
        .highlight { color: #fff; font-weight: 700; }
        
        #mode-indicator {
            position: absolute; bottom: 30px; left: 50%;
            transform: translateX(-50%);
            font-size: 2rem; font-weight: 900;
            color: rgba(255, 255, 255, 0.8);
            pointer-events: none;
            letter-spacing: 4px;
            text-shadow: 0 0 20px rgba(0, 255, 204, 0.3);
        }
        
        #gesture-feedback {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(0.5);
            font-size: 4rem; opacity: 0;
            pointer-events: none;
            transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        #gesture-feedback.show { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
        
        .stat-bar {
            border-left: 2px solid rgba(0, 255, 204, 0.2);
            padding-left: 8px;
        }
        
        .section-title {
            color: #d600b2;
            margin-top: 12px; margin-bottom: 6px;
            font-size: 0.85rem; border-bottom: 1px solid rgba(214, 0, 178, 0.2);
        }
        
        #feature-panel {
            position: absolute; top: 20px; right: 20px;
            background: linear-gradient(135deg, rgba(20, 0, 20, 0.6) 0%, rgba(10, 0, 10, 0.5) 100%);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid rgba(255, 0, 204, 0.1);
            color: white;
            backdrop-filter: blur(8px);
            pointer-events: none;
        }
        
        .feature-item { font-size: 0.75rem; margin: 5px 0; padding: 4px 8px; opacity: 0.6; }
        .feature-active { opacity: 1; color: #00ff88; border-left: 2px solid #00ff88; background: rgba(0, 255, 136, 0.05); }

        .help-toggle {
            position: absolute; bottom: 20px; left: 20px;
            background: rgba(255, 255, 255, 0.1);
            color: white; border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 8px 16px; border-radius: 8px; cursor: pointer;
            font-family: inherit; font-size: 0.8rem; pointer-events: auto;
            transition: background 0.2s;
        }
        .help-toggle:hover { background: rgba(255, 255, 255, 0.2); }
    </style>
</head>
<body>

    <div id="ui">
        <h1>NebulaTouch v3.1</h1>
        <p>Status: <span id="status-text" class="highlight">IDLE</span></p>
        <p class="stat-bar">Shape: <span id="shape-name" class="highlight">SPHERE</span></p>
        <p class="stat-bar">Hands: <span id="hand-count" class="highlight">0</span></p>
        <hr style="border-color: rgba(255,255,255,0.1); margin: 10px 0;">
        
        <p class="section-title">ONE HAND (HOLD TO TRIGGER)</p>
        <p>üëã <b>Swipe Fast:</b> Next/Prev Shape</p>
        <p>‚úåÔ∏è <b>Hold Peace:</b> Auto-Rotate</p>
        <p>üëç <b>Hold Thumb Up:</b> Random Color</p>
        <p>üëé <b>Hold Thumb Down:</b> Reset</p>
        <p>‚òùÔ∏è <b>Hold Point:</b> Speed Up</p>
        <p>ü§ò <b>Hold Rock:</b> Explode</p>
        <p>üññ <b>Hold Vulcan:</b> Freeze</p>
        
        <p class="section-title">TWO HANDS</p>
        <p>ü§≤ <b>Open Palms:</b> Gravity</p>
        <p>üëè <b>Clap:</b> Shockwave</p>
        <p>ü§è <b>Pinch Both:</b> Zoom</p>
    </div>

    <div id="feature-panel">
        <h3 style="margin: 0 0 10px 0; font-size: 0.9rem; color: #ff00cc;">ACTIVE</h3>
        <div class="feature-item"><span id="f-auto-rotate">Auto-Rotate</span></div>
        <div class="feature-item"><span id="f-gravity">Gravity Field</span></div>
        <div class="feature-item"><span id="f-freeze">Freeze</span></div>
        <div class="feature-item"><span id="f-trails">Trails</span></div>
        <div class="feature-item"><span id="f-pulsate">Pulsate</span></div>
    </div>

    <button class="help-toggle" onclick="toggleUI()">Hide UI</button>
    <div id="mode-indicator">Ready</div>
    <div id="gesture-feedback"></div>
    <canvas id="particle-trail" style="position:absolute; top:0; left:0; pointer-events:none; mix-blend-mode:screen;"></canvas>
    <video id="video-input" playsinline></video>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // --- AUDIO SYSTEM ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playSound(freq, dur, type = 'sine') {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.frequency.value = freq;
            osc.type = type;
            gain.gain.setValueAtTime(0.05, audioCtx.currentTime); // Lower volume
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
            osc.start();
            osc.stop(audioCtx.currentTime + dur);
        }

        // --- CONFIG & STATE ---
        const CONFIG = {
            particleCount: 8000, // Optimized count
            camZ: 40,
            swipeThreshold: 0.6, // Lowered slightly
            motionThreshold: 0.15, // Threshold to consider hand "moving"
            gestureHoldFrames: 12, // FRAMES TO HOLD A GESTURE BEFORE TRIGGER
            pinchThreshold: 0.05
        };

        const state = {
            mode: 'SHAPE', // Only SHAPE mode for stability
            hand: { x: 0, y: 0 },
            velocity: 0,
            lastHandX: 0,
            isPinching: false,
            
            // Features
            autoRotate: false,
            gravityField: false,
            freeze: false,
            pulsate: false,
            
            // Logic Control
            cooldown: 0,
            currentShapeIdx: 0,
            
            // Gesture Stabilizer
            gestureBuffer: null,
            gestureCounter: 0,
            
            // Visuals
            fps: 60,
            lastTime: Date.now()
        };

        // --- 3D SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050510, 0.015); // Darker fog
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = CONFIG.camZ;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // --- PARTICLES ---
        const particles = new THREE.BufferGeometry();
        const count = CONFIG.particleCount;
        const pos = new Float32Array(count * 3);
        const targetPos = new Float32Array(count * 3);
        const cols = new Float32Array(count * 3);
        
        for(let i=0; i<count*3; i++) {
            pos[i] = (Math.random()-0.5)*100;
            targetPos[i] = pos[i];
            cols[i] = 1;
        }
        
        particles.setAttribute('position', new THREE.BufferAttribute(pos, 3));
        particles.setAttribute('color', new THREE.BufferAttribute(cols, 3));
        
        const material = new THREE.PointsMaterial({
            size: 0.35, vertexColors: true, blending: THREE.AdditiveBlending,
            transparent: true, opacity: 0.8, depthWrite: false
        });
        
        const particleSystem = new THREE.Points(particles, material);
        scene.add(particleSystem);

        // --- SHAPE LIBRARY ---
        const shapes = {
            'sphere': (i) => {
                const r = 12, theta = Math.random()*Math.PI*2, phi = Math.acos(2*Math.random()-1);
                return [r*Math.sin(phi)*Math.cos(theta), r*Math.sin(phi)*Math.sin(theta), r*Math.cos(phi)];
            },
            'cube': (i) => {
                const s = 14;
                return [(Math.random()-0.5)*s*2, (Math.random()-0.5)*s*2, (Math.random()-0.5)*s*2];
            },
            'torus': (i) => {
                const u = Math.random()*6.28, v = Math.random()*6.28, R=10, r=4;
                return [(R+r*Math.cos(v))*Math.cos(u), (R+r*Math.cos(v))*Math.sin(u), r*Math.sin(v)];
            },
            'helix': (i) => {
                const t = i*0.01, r=6;
                return [r*Math.cos(t), (i/count-0.5)*40, r*Math.sin(t)];
            }
        };
        const shapeKeys = Object.keys(shapes);

        function morph(name) {
            const func = shapes[name];
            document.getElementById('shape-name').innerText = name.toUpperCase();
            document.getElementById('mode-indicator').innerText = name.toUpperCase();
            document.getElementById('mode-indicator').style.opacity = 1;
            setTimeout(() => document.getElementById('mode-indicator').style.opacity = 0, 1000);
            
            for(let i=0; i<count; i++) {
                const [x,y,z] = func(i);
                targetPos[i*3] = x; targetPos[i*3+1] = y; targetPos[i*3+2] = z;
                
                // Set color based on shape to distinguish them
                const c = new THREE.Color().setHSL(Math.random(), 0.8, 0.5);
                if(name === 'sphere') c.setHSL(0.6, 1, 0.5); // Blue
                if(name === 'cube') c.setHSL(0.1, 1, 0.5); // Orange
                if(name === 'torus') c.setHSL(0.8, 1, 0.5); // Pink
                
                cols[i*3] = c.r; cols[i*3+1] = c.g; cols[i*3+2] = c.b;
            }
            particles.attributes.color.needsUpdate = true;
            playSound(400, 0.1);
        }

        morph('sphere');

        // --- GESTURE & LOGIC ENGINE ---
        
        function detectHandPose(lm) {
            // Helper: is finger tip above MCP joint? (y is inverted)
            const isUp = (tip, mcp) => lm[tip].y < lm[mcp].y;
            const idxUp = isUp(8, 5);
            const midUp = isUp(12, 9);
            const rngUp = isUp(16, 13);
            const pnkUp = isUp(20, 17);
            const thumbOut = lm[4].x < lm[3].x; // Right hand assumption roughly

            if (idxUp && midUp && !rngUp && !pnkUp) return 'peace';
            if (idxUp && !midUp && !rngUp && !pnkUp) return 'point';
            if (idxUp && !midUp && !rngUp && pnkUp) return 'rock';
            if (!idxUp && !midUp && !rngUp && !pnkUp) {
                return lm[4].y < lm[3].y ? 'thumb_up' : 'thumb_down';
            }
            if (idxUp && midUp && rngUp && pnkUp) {
                // Check if vulcan spread
                if (Math.abs(lm[12].x - lm[16].x) > 0.08) return 'vulcan'; 
                return 'open';
            }
            return null;
        }

        function updateStatus(text) {
            document.getElementById('status-text').innerText = text;
        }

        function updateFeature(id, active) {
            const el = document.getElementById('f-'+id);
            if(el) el.className = active ? 'feature-active' : 'feature-item';
        }

        function onResults(results) {
            const hands = results.multiHandLandmarks;
            const handCount = hands ? hands.length : 0;
            document.getElementById('hand-count').innerText = handCount;

            if (state.cooldown > 0) state.cooldown--;

            if (handCount > 0) {
                const lm = hands[0];
                const x = (lm[8].x - 0.5) * -40; // Map to 3D space
                const y = (lm[8].y - 0.5) * -30;
                
                // 1. Calculate Velocity
                const dx = x - state.lastHandX;
                state.velocity = dx;
                state.lastHandX = x;
                state.hand.x = x;
                state.hand.y = y;
                
                const speed = Math.abs(dx);
                const isMoving = speed > CONFIG.motionThreshold;

                // 2. Detect Interaction (Pinch)
                const pinchDist = Math.hypot(lm[8].x - lm[4].x, lm[8].y - lm[4].y);
                state.isPinching = pinchDist < CONFIG.pinchThreshold;

                // --- PRIORITY LOGIC TREE ---

                if (state.cooldown > 0) return; // Busy

                // PRIORITY 1: SWIPE (High Motion)
                if (speed > CONFIG.swipeThreshold) {
                    if (dx > 0) state.currentShapeIdx = (state.currentShapeIdx + 1) % shapeKeys.length;
                    else state.currentShapeIdx = (state.currentShapeIdx - 1 + shapeKeys.length) % shapeKeys.length;
                    
                    morph(shapeKeys[state.currentShapeIdx]);
                    updateStatus("SWIPING");
                    state.cooldown = 20; // Lock input
                    state.gestureBuffer = null; // Reset gestures
                    return;
                }

                // PRIORITY 2: INTERACTION (Pinching)
                if (state.isPinching) {
                    updateStatus("PINCHING");
                    // Reset View if needed or Drag logic (omitted for stability)
                    state.gestureBuffer = null;
                    return;
                }

                // PRIORITY 3: MOTION (Moving Hand rotates view)
                if (isMoving) {
                    updateStatus("ROTATING");
                    if (!state.autoRotate) {
                        // Direct rotation mapping
                        particleSystem.rotation.y = x * 0.05;
                        particleSystem.rotation.x = -y * 0.05;
                    }
                    state.gestureBuffer = null; // Cannot gesture while moving
                    return;
                }

                // PRIORITY 4: STATIC GESTURES (Hand is still)
                updateStatus("DETECTING...");
                const rawGesture = detectHandPose(lm);
                
                // Stabilizer Logic
                if (rawGesture && rawGesture === state.gestureBuffer) {
                    state.gestureCounter++;
                    if (state.gestureCounter > CONFIG.gestureHoldFrames) {
                        // EXECUTE COMMAND
                        executeCommand(rawGesture);
                        state.gestureCounter = 0; // Reset
                        state.cooldown = 30; // Cooldown after successful trigger
                    }
                } else {
                    state.gestureBuffer = rawGesture;
                    state.gestureCounter = 0;
                }
            }
        }

        function executeCommand(gesture) {
            const fb = document.getElementById('gesture-feedback');
            
            function show(emoji) {
                fb.innerText = emoji;
                fb.classList.add('show');
                setTimeout(() => fb.classList.remove('show'), 800);
            }

            switch(gesture) {
                case 'peace':
                    state.autoRotate = !state.autoRotate;
                    updateFeature('auto-rotate', state.autoRotate);
                    show(state.autoRotate ? 'üîÑ' : '‚è∏Ô∏è');
                    break;
                case 'thumb_up':
                    // Randomize Colors
                    for(let i=0; i<count*3; i+=3) {
                        cols[i] = Math.random(); cols[i+1] = Math.random(); cols[i+2] = Math.random();
                    }
                    particles.attributes.color.needsUpdate = true;
                    show('üé®');
                    break;
                case 'thumb_down':
                    state.autoRotate = false;
                    state.gravityField = false;
                    particleSystem.rotation.set(0,0,0);
                    updateFeature('auto-rotate', false);
                    updateFeature('gravity', false);
                    show('RESET');
                    break;
                case 'open':
                    state.gravityField = !state.gravityField;
                    updateFeature('gravity', state.gravityField);
                    show(state.gravityField ? 'üåå' : '‚≠ï');
                    break;
                case 'vulcan':
                    state.freeze = !state.freeze;
                    updateFeature('freeze', state.freeze);
                    show(state.freeze ? '‚ùÑÔ∏è' : '‚ñ∂Ô∏è');
                    break;
                case 'rock':
                    // Explosion visual only
                    show('üí•');
                    break;
            }
            playSound(600, 0.15, 'triangle');
        }

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            
            // Physics
            const posAttr = particles.attributes.position;
            const positions = posAttr.array;
            
            for(let i=0; i<count; i++) {
                const idx = i*3;
                
                // Gravity Logic
                if (state.gravityField && !state.freeze) {
                    const dx = state.hand.x - positions[idx];
                    const dy = state.hand.y - positions[idx+1];
                    const distSq = dx*dx + dy*dy + 1;
                    const f = 0.5 / distSq;
                    positions[idx] += dx*f;
                    positions[idx+1] += dy*f;
                }
                else if (!state.freeze) {
                    // Return to shape
                    const ease = 0.08;
                    positions[idx] += (targetPos[idx] - positions[idx]) * ease;
                    positions[idx+1] += (targetPos[idx+1] - positions[idx+1]) * ease;
                    positions[idx+2] += (targetPos[idx+2] - positions[idx+2]) * ease;
                }
            }
            posAttr.needsUpdate = true;

            // Auto Rotate
            if (state.autoRotate) {
                particleSystem.rotation.y += 0.005;
            }

            renderer.render(scene, camera);
        }

        // --- INIT ---
        const videoElement = document.getElementById('video-input');
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
        hands.onResults(onResults);
        
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        });
        cameraUtils.start();
        
        function toggleUI() {
            const ui = document.getElementById('ui');
            ui.style.opacity = ui.style.opacity === '0' ? '1' : '0';
        }
        
        animate();
    </script>
</body>
</html>
