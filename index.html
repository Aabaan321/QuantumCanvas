<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>NebulaTouch v2: Gesture OS</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Courier New', Courier, monospace; }
        canvas { display: block; }
        #video-input { position: absolute; top: 0; left: 0; opacity: 0; pointer-events: none; }
        #ui {
            position: absolute;
            top: 20px; left: 20px;
            color: #00ffcc;
            pointer-events: none;
            z-index: 10;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #00ffcc;
        }
        h1 { margin: 0; font-size: 1.2rem; text-transform: uppercase; letter-spacing: 2px; }
        p { font-size: 0.9rem; margin: 5px 0; opacity: 0.9; }
        .highlight { color: #fff; font-weight: bold; }
        #mode-indicator {
            position: absolute;
            bottom: 30px; left: 50%;
            transform: translateX(-50%);
            font-size: 1.5rem;
            color: white;
            text-shadow: 0 0 10px #00ffcc;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="ui">
        <h1>NebulaTouch v2</h1>
        <p>Current Mode: <span id="mode-text" class="highlight">SHAPE VIEW</span></p>
        <hr style="border-color: #333">
        <div id="instructions-shape">
            <p>üëã <b>Swipe Fast:</b> Scroll Shapes</p>
            <p>ü§è <b>Pinch Distance:</b> Resize Object</p>
            <p>‚úã <b>Move Slow:</b> Rotate View</p>
        </div>
        <div id="instructions-draw" style="display:none;">
            <p>ü§è <b>Pinch & Move:</b> Draw in 3D</p>
            <p>‚úã <b>Release:</b> Stop Drawing</p>
        </div>
        <p style="margin-top:10px; font-size: 0.7rem; color: #aaa;">* Click (Pinch) the floating orbs to switch modes</p>
    </div>

    <div id="mode-indicator">Loading AI...</div>
    <video id="video-input" playsinline></video>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // --- CONFIGURATION ---
        const CONFIG = {
            particleCount: 6000,
            camZ: 40,
            swipeThreshold: 0.8, // Speed required to trigger swipe
            pinchThreshold: 0.05, // Distance to trigger "click" or "draw"
            drawDistance: 30 // Z-depth for drawing
        };

        // --- STATE MANAGEMENT ---
        const state = {
            mode: 'SHAPE', // 'SHAPE' or 'DRAW'
            hand: { x: 0, y: 0, z: 0 },
            lastHandX: 0,
            velocity: 0,
            pinchDist: 0.1,
            isPinching: false,
            swipeCooldown: 0,
            currentShapeIdx: 0
        };

        // --- THREE.JS SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.015);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = CONFIG.camZ;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- 1. SHAPE PARTICLE SYSTEM ---
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(CONFIG.particleCount * 3);
        const targetPositions = new Float32Array(CONFIG.particleCount * 3);
        const colors = new Float32Array(CONFIG.particleCount * 3);

        for (let i = 0; i < CONFIG.particleCount * 3; i++) {
            positions[i] = (Math.random() - 0.5) * 100;
            targetPositions[i] = positions[i];
            colors[i] = 1;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({
            size: 0.2,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            transparent: true,
            opacity: 0.8
        });

        const particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);

        // --- 2. DRAWING SYSTEM (LINES) ---
        const drawMaterial = new THREE.LineBasicMaterial({ color: 0xff00cc, linewidth: 2 });
        // We will store lines in a group
        const drawingGroup = new THREE.Group();
        scene.add(drawingGroup);
        
        let currentLine = null;
        let currentLineGeo = null;
        let currentLinePositions = [];

        function startStroke() {
            currentLinePositions = [];
            currentLineGeo = new THREE.BufferGeometry();
            currentLine = new THREE.Line(currentLineGeo, drawMaterial);
            drawingGroup.add(currentLine);
        }

        function updateStroke(x, y) {
            if (!currentLine) return;
            // Add point to current line
            currentLinePositions.push(x, y, 0); // Draw on Z=0 plane
            const posAttr = new THREE.Float32BufferAttribute(currentLinePositions, 3);
            currentLineGeo.setAttribute('position', posAttr);
        }

        function endStroke() {
            currentLine = null;
        }

        // --- 3. UI BUTTONS (VIRTUAL 3D OBJECTS) ---
        // Left Button (Shapes)
        const btnShapeGeo = new THREE.SphereGeometry(2, 32, 32);
        const btnShapeMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true });
        const btnShape = new THREE.Mesh(btnShapeGeo, btnShapeMat);
        btnShape.position.set(-15, -10, 10);
        scene.add(btnShape);

        // Right Button (Draw)
        const btnDrawGeo = new THREE.SphereGeometry(2, 32, 32);
        const btnDrawMat = new THREE.MeshBasicMaterial({ color: 0xff00cc, wireframe: true });
        const btnDraw = new THREE.Mesh(btnDrawGeo, btnDrawMat);
        btnDraw.position.set(15, -10, 10);
        scene.add(btnDraw);

        // --- SHAPE GENERATORS ---
        const shapeFormulas = {
            'sphere': (i) => {
                const r = 12;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                return [r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi), 0.1, 0.8, 1.0];
            },
            'heart': (i) => {
                const t = Math.random() * Math.PI * 2;
                const scale = 0.8;
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                const z = (Math.random() - 0.5) * 6;
                return [x * scale, y * scale, z, 1.0, 0.2, 0.4];
            },
            'saturn': (i) => {
                let x,y,z,r,g,b;
                if (Math.random() > 0.4) {
                    // Rings
                    const theta = Math.random() * Math.PI * 2;
                    const rad = 10 + Math.random() * 8;
                    x = rad * Math.cos(theta);
                    z = rad * Math.sin(theta);
                    y = (Math.random()-0.5);
                    r=0.8; g=0.7; b=0.3;
                } else {
                    // Planet
                    const rad = 6;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    x = rad * Math.sin(phi) * Math.cos(theta);
                    y = rad * Math.sin(phi) * Math.sin(theta);
                    z = rad * Math.cos(phi);
                    r=0.9; g=0.5; b=0.1;
                }
                return [x,y,z,r,g,b];
            },
            'flower': (i) => {
                const k = 5;
                const theta = Math.random() * Math.PI * 2;
                const rad = 10 * Math.cos(k * theta) + 5;
                const x = rad * Math.cos(theta);
                const y = rad * Math.sin(theta);
                const z = (Math.random() - 0.5) * 5;
                return [x, y, z, 0.8, 0.1, 0.9];
            }
        };

        const shapeKeys = Object.keys(shapeFormulas);

        function morphToShape(name) {
            const func = shapeFormulas[name];
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const [x, y, z, r, g, b] = func(i);
                const idx = i * 3;
                targetPositions[idx] = x;
                targetPositions[idx+1] = y;
                targetPositions[idx+2] = z;
                colors[idx] = r; colors[idx+1] = g; colors[idx+2] = b;
            }
            geometry.attributes.color.needsUpdate = true;
            document.getElementById('mode-indicator').innerText = name.toUpperCase();
        }

        morphToShape('sphere'); // Init

        // --- MEDIAPIPE HANDLER ---
        function onResults(results) {
            document.getElementById('mode-indicator').innerText = state.mode === 'SHAPE' ? shapeKeys[state.currentShapeIdx].toUpperCase() : "DRAW MODE";

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];

                // Get Coordinates
                const idxFinger = landmarks[8];
                const thumb = landmarks[4];
                
                // Map to 3D world space (approx)
                const x = (idxFinger.x - 0.5) * -40;
                const y = (idxFinger.y - 0.5) * -30;
                
                // Calculate Velocity for Swipe
                state.velocity = x - state.lastHandX;
                state.lastHandX = x;

                state.hand.x = x;
                state.hand.y = y;

                // Calculate Pinch Distance
                const dist = Math.sqrt(
                    Math.pow(idxFinger.x - thumb.x, 2) + 
                    Math.pow(idxFinger.y - thumb.y, 2)
                );
                state.pinchDist = dist;
                const wasPinching = state.isPinching;
                state.isPinching = dist < CONFIG.pinchThreshold;

                // --- GESTURE LOGIC ---

                // 1. Button Clicking (Mode Switching)
                if (state.isPinching && !wasPinching) {
                    // Check Left Button (Shape Mode)
                    if (Math.abs(x - btnShape.position.x) < 5 && Math.abs(y - btnShape.position.y) < 5) {
                        state.mode = 'SHAPE';
                        document.getElementById('mode-text').innerText = "SHAPE VIEW";
                        document.getElementById('instructions-shape').style.display = 'block';
                        document.getElementById('instructions-draw').style.display = 'none';
                        particleSystem.visible = true;
                        drawingGroup.visible = false;
                        btnShape.material.color.setHex(0xffffff); // Flash
                        setTimeout(() => btnShape.material.color.setHex(0x00ffff), 200);
                    }
                    // Check Right Button (Draw Mode)
                    else if (Math.abs(x - btnDraw.position.x) < 5 && Math.abs(y - btnDraw.position.y) < 5) {
                        state.mode = 'DRAW';
                        document.getElementById('mode-text').innerText = "DRAWING";
                        document.getElementById('instructions-shape').style.display = 'none';
                        document.getElementById('instructions-draw').style.display = 'block';
                        particleSystem.visible = false; // Hide shapes to focus on drawing
                        drawingGroup.visible = true;
                        btnDraw.material.color.setHex(0xffffff); // Flash
                        setTimeout(() => btnDraw.material.color.setHex(0xff00cc), 200);
                    }
                }

                // 2. Shape Mode Logic
                if (state.mode === 'SHAPE') {
                    // Swipe Detection (Cooldown prevents rapid firing)
                    if (state.swipeCooldown <= 0) {
                        if (state.velocity > CONFIG.swipeThreshold) {
                            // Swipe Right -> Next Shape
                            state.currentShapeIdx = (state.currentShapeIdx + 1) % shapeKeys.length;
                            morphToShape(shapeKeys[state.currentShapeIdx]);
                            state.swipeCooldown = 20; // Frames to wait
                        } else if (state.velocity < -CONFIG.swipeThreshold) {
                            // Swipe Left -> Prev Shape
                            state.currentShapeIdx = (state.currentShapeIdx - 1 + shapeKeys.length) % shapeKeys.length;
                            morphToShape(shapeKeys[state.currentShapeIdx]);
                            state.swipeCooldown = 20;
                        }
                    } else {
                        state.swipeCooldown--;
                    }
                }

                // 3. Draw Mode Logic
                if (state.mode === 'DRAW') {
                    if (state.isPinching) {
                        if (!currentLine) startStroke();
                        updateStroke(x, y);
                    } else {
                        if (currentLine) endStroke();
                    }
                }

            }
        }

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            // Smoothly interpolate particles
            const positionsArr = geometry.attributes.position.array;
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const idx = i * 3;
                // Move towards target
                positionsArr[idx] += (targetPositions[idx] - positionsArr[idx]) * 0.08;
                positionsArr[idx+1] += (targetPositions[idx+1] - positionsArr[idx+1]) * 0.08;
                positionsArr[idx+2] += (targetPositions[idx+2] - positionsArr[idx+2]) * 0.08;
            }
            geometry.attributes.position.needsUpdate = true;

            // Handle View Rotation & Scaling based on Hand
            if (state.mode === 'SHAPE') {
                // Rotation: Only rotate if velocity is low (not swiping)
                if (Math.abs(state.velocity) < 0.3) {
                    particleSystem.rotation.y += (state.hand.x * 0.001);
                    particleSystem.rotation.x -= (state.hand.y * 0.001);
                }

                // Scaling: Map pinch distance (0.02 - 0.2) to Scale (0.5 - 2.5)
                // We constrain it so it doesn't vanish or get too huge
                const targetScale = Math.max(0.5, Math.min(3.0, state.pinchDist * 10)); 
                particleSystem.scale.setScalar(THREE.MathUtils.lerp(particleSystem.scale.x, targetScale, 0.1));
            }

            // Animate Buttons (Float/Spin)
            const time = Date.now() * 0.001;
            btnShape.rotation.y = time;
            btnDraw.rotation.y = -time;
            btnShape.position.y = -10 + Math.sin(time) * 0.5;
            btnDraw.position.y = -10 + Math.sin(time + 1) * 0.5;

            renderer.render(scene, camera);
        }

        // --- INITIALIZATION ---
        const videoElement = document.getElementById('video-input');
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        hands.onResults(onResults);
        
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        });
        cameraUtils.start();
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
