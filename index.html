<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>NebulaTouch v3: Symbiotic Core</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; }
        
        /* UI OVERLAY */
        #hud {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
            padding: 20px; box-sizing: border-box;
        }

        .hud-panel {
            background: rgba(10, 20, 40, 0.7);
            border: 1px solid rgba(0, 255, 200, 0.3);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 8px;
            color: #0ff;
            max-width: 300px;
            pointer-events: auto; /* Allow clicking buttons */
        }

        h1 { margin: 0 0 10px 0; font-size: 1.1rem; letter-spacing: 2px; text-transform: uppercase; color: #fff; }
        p { margin: 5px 0; font-size: 0.85rem; color: #aaa; display: flex; justify-content: space-between; }
        
        .status-badge {
            background: #004433; color: #00ffcc; padding: 2px 6px; border-radius: 4px; font-size: 0.7rem; font-weight: bold;
        }

        #active-gesture {
            font-size: 1.5rem; color: white; text-align: center; 
            text-shadow: 0 0 20px #00ffcc; letter-spacing: 3px;
            position: absolute; top: 10%; left: 50%; transform: translateX(-50%);
        }

        /* BUTTONS */
        .btn {
            background: transparent; border: 1px solid #0ff; color: #0ff;
            padding: 8px 16px; margin-top: 10px; cursor: pointer;
            font-family: inherit; text-transform: uppercase; font-size: 0.75rem;
            transition: all 0.3s; width: 100%;
        }
        .btn:hover { background: rgba(0, 255, 255, 0.2); }
        .btn.active { background: #0ff; color: #000; box-shadow: 0 0 15px #0ff; }

        /* INTRO SCREEN */
        #intro {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        #intro button {
            padding: 15px 40px; font-size: 1.2rem; background: #00ffcc; border: none;
            color: #000; font-weight: bold; cursor: pointer; letter-spacing: 2px;
            box-shadow: 0 0 30px rgba(0,255,204,0.5);
        }
        #intro button:hover { transform: scale(1.05); }

        /* LOADING */
        #loader { display: none; color: #0ff; margin-top: 20px; animation: blink 1s infinite; }
        @keyframes blink { 50% { opacity: 0.5; } }
        
        video { display: none; }
    </style>
</head>
<body>

    <div id="intro">
        <h1 style="font-size: 3rem; color: white; text-shadow: 0 0 20px cyan;">NEBULA TOUCH v3</h1>
        <p style="color: #888; margin-bottom: 30px;">Webcam & Microphone Required for Full Experience</p>
        <button onclick="startSystem()">INITIALIZE SYSTEM</button>
        <div id="loader">CALIBRATING SENSORS...</div>
    </div>

    <div id="hud">
        <div class="hud-panel">
            <h1>System Status</h1>
            <p>Tracking: <span id="status-track" class="status-badge">SEARCHING</span></p>
            <p>Microphone: <span id="status-mic" class="status-badge" style="background:#330000; color:#ff5555">OFF</span></p>
            <p>Particles: <span class="status-badge">8000</span></p>
            <hr style="border-color: rgba(0,255,255,0.2)">
            <button id="btn-audio" class="btn" onclick="toggleAudio()">Enable Audio Reactor</button>
        </div>

        <div id="active-gesture"></div>

        <div class="hud-panel" style="align-self: flex-end;">
            <h1>Capabilities</h1>
            <p>üëê <b>Dual Hands:</b> Gravity Well / Stretch</p>
            <p>‚úåÔ∏è <b>Peace Sign:</b> Split Galaxy</p>
            <p>‚úä <b>Fist:</b> Chaos Explosion</p>
            <p>‚òùÔ∏è <b>Index:</b> Comet Trail</p>
            <p>üó£Ô∏è <b>Voice:</b> Pulse & Spin Speed</p>
        </div>
    </div>

    <video id="video-input" playsinline></video>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

    <script>
        // --- CONFIGURATION ---
        const CONFIG = {
            count: 8000,
            colorPalettes: [
                [new THREE.Color('#00ffff'), new THREE.Color('#ff00ff'), new THREE.Color('#ffffff')], // Cyber
                [new THREE.Color('#ffaa00'), new THREE.Color('#ff0000'), new THREE.Color('#ffff00')], // Fire
                [new THREE.Color('#aaddff'), new THREE.Color('#ffffff'), new THREE.Color('#8888ff')]  // Ice
            ]
        };

        // --- GLOBAL STATE ---
        const state = {
            hands: [],
            audioData: 0,
            audioEnabled: false,
            shapeIdx: 0,
            paletteIdx: 0,
            gesture: 'IDLE',
            swipeCooldown: 0,
            smoothHand: { x: 0, y: 0, z: 0 }, // For smoothing
            particles: null
        };

        // --- AUDIO SYSTEM ---
        let audioCtx, analyser, dataArray;
        function initAudio() {
            if (state.audioEnabled) return;
            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
                    const source = audioCtx.createMediaStreamSource(stream);
                    analyser = audioCtx.createAnalyser();
                    analyser.fftSize = 64;
                    source.connect(analyser);
                    dataArray = new Uint8Array(analyser.frequencyBinCount);
                    state.audioEnabled = true;
                    document.getElementById('status-mic').innerText = "ACTIVE";
                    document.getElementById('status-mic').style.backgroundColor = "#004400";
                    document.getElementById('status-mic').style.color = "#00ff00";
                    document.getElementById('btn-audio').classList.add('active');
                });
            } catch (e) {
                console.error("Mic Error", e);
            }
        }
        function toggleAudio() { initAudio(); }

        function getAudioLevel() {
            if (!state.audioEnabled || !analyser) return 0;
            analyser.getByteFrequencyData(dataArray);
            let sum = 0;
            for(let i=0; i < dataArray.length; i++) sum += dataArray[i];
            return sum / dataArray.length; // 0 to 255
        }

        // --- THREE.JS ENGINE ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.z = 30;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // PARTICLE SYSTEM
        const geometry = new THREE.BufferGeometry();
        const posArray = new Float32Array(CONFIG.count * 3);
        const targetArray = new Float32Array(CONFIG.count * 3);
        const colorArray = new Float32Array(CONFIG.count * 3);
        const sizesArray = new Float32Array(CONFIG.count); // Individual sizes

        for(let i=0; i<CONFIG.count*3; i++) {
            posArray[i] = (Math.random()-0.5)*50;
            targetArray[i] = posArray[i];
            colorArray[i] = 1;
        }
        for(let i=0; i<CONFIG.count; i++) sizesArray[i] = Math.random();

        geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        geometry.setAttribute('target', new THREE.BufferAttribute(targetArray, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));
        geometry.setAttribute('size', new THREE.BufferAttribute(sizesArray, 1));

        // Custom Shader Material for Glow and Pulse
        const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/spark1.png');
        const material = new THREE.ShaderMaterial({
            uniforms: {
                pointTexture: { value: sprite },
                globalSize: { value: 20.0 },
                time: { value: 0 }
            },
            vertexShader: `
                attribute float size;
                attribute vec3 color;
                varying vec3 vColor;
                uniform float globalSize;
                void main() {
                    vColor = color;
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    gl_PointSize = size * globalSize * (30.0 / -mvPosition.z);
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                uniform sampler2D pointTexture;
                varying vec3 vColor;
                void main() {
                    gl_FragColor = vec4(vColor, 1.0) * texture2D(pointTexture, gl_PointCoord);
                }
            `,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // TRAIL SYSTEM (Index Finger)
        const trailGeo = new THREE.BufferGeometry();
        const trailMaxPoints = 50;
        const trailPositions = new Float32Array(trailMaxPoints * 3);
        trailGeo.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
        const trailMat = new THREE.LineBasicMaterial({ color: 0xff00ff, transparent: true, opacity: 0.5 });
        const trailLine = new THREE.Line(trailGeo, trailMat);
        scene.add(trailLine);
        let trailIdx = 0;

        // --- SHAPE MATH ---
        function getShapePos(type, i) {
            let x,y,z;
            const idx = i; 
            // Normalized 0-1
            const r1 = Math.random(); const r2 = Math.random();

            if (type === 'sphere') {
                const r = 10;
                const theta = r1 * Math.PI * 2;
                const phi = Math.acos(2 * r2 - 1);
                x = r * Math.sin(phi) * Math.cos(theta);
                y = r * Math.sin(phi) * Math.sin(theta);
                z = r * Math.cos(phi);
            } else if (type === 'galaxy') {
                const arms = 5;
                const spin = i * 0.01;
                const r = r1 * 15;
                const angle = spin + (r * 0.2);
                x = r * Math.cos(angle);
                y = (Math.random()-0.5) * (r*0.5); // flatten
                z = r * Math.sin(angle);
            } else if (type === 'cube') {
                const s = 15;
                x = (Math.random()-0.5)*s; 
                y = (Math.random()-0.5)*s; 
                z = (Math.random()-0.5)*s; 
            }
            return {x,y,z};
        }

        const shapes = ['galaxy', 'sphere', 'cube'];
        
        function updateTargets() {
            const shape = shapes[state.shapeIdx];
            const t = particles.geometry.attributes.target.array;
            for(let i=0; i<CONFIG.count; i++) {
                const p = getShapePos(shape, i);
                t[i*3] = p.x;
                t[i*3+1] = p.y;
                t[i*3+2] = p.z;
            }
        }
        updateTargets(); // Init

        // --- LOGIC LOOP ---
        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            const positions = particles.geometry.attributes.position.array;
            const targets = particles.geometry.attributes.target.array;
            const colors = particles.geometry.attributes.color.array;

            // 1. Audio Analysis
            const audioLevel = getAudioLevel(); // 0-255
            const audioFactor = audioLevel / 255; // 0.0-1.0
            
            // Audio Reaction: Pulse Size
            material.uniforms.globalSize.value = 20.0 + (audioFactor * 30.0);
            
            // 2. Gesture Logic
            let rotSpeed = 0.05 + (audioFactor * 0.2); // Voice speeds up rotation
            let chaos = 0;
            let gravityCenter = null;
            let stretchFactor = 1;
            let splitMode = false;

            // Detect Gestures
            if (state.hands.length > 0) {
                const h1 = state.hands[0];
                const h2 = state.hands[1];

                // SMOOTHING
                state.smoothHand.x += (h1.x - state.smoothHand.x) * 0.1;
                state.smoothHand.y += (h1.y - state.smoothHand.y) * 0.1;
                
                // --- TWO HAND GESTURES ---
                if (state.hands.length === 2) {
                    const dx = h1.x - h2.x;
                    const dy = h1.y - h2.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);

                    if (dist < 5) {
                        state.gesture = "BLACK HOLE";
                        gravityCenter = { x: (h1.x+h2.x)/2, y: (h1.y+h2.y)/2, z: 0 };
                        chaos = 2; // Shake
                    } else if (dist > 15) {
                        state.gesture = "COSMIC STRETCH";
                        stretchFactor = 1 + (dist - 15) * 0.1;
                    } else {
                        state.gesture = "DUAL SYNC";
                    }
                } 
                // --- ONE HAND GESTURES ---
                else {
                    // Check Finger States (Simple heuristics)
                    // H1.fingers = [Thumb, Index, Middle, Ring, Pinky] (1=Open, 0=Closed)
                    
                    if (h1.isFist) {
                        state.gesture = "CHAOS EXPLOSION";
                        chaos = 5;
                    } else if (h1.isPeace) {
                        state.gesture = "SPLIT REALITY";
                        splitMode = true;
                    } else {
                        state.gesture = "ORBITAL CONTROL";
                        // Trail Logic
                        if (h1.indexOpen) {
                            // Update Trail
                            for(let j=trailMaxPoints*3-1; j>=3; j--) trailPositions[j] = trailPositions[j-3];
                            trailPositions[0] = h1.rawX * 20; // Scale up for visibility
                            trailPositions[1] = h1.rawY * 20;
                            trailPositions[2] = 5;
                            trailLine.geometry.attributes.position.needsUpdate = true;
                        }
                    }
                    
                    // Interaction: Rotate
                    particles.rotation.y += (state.smoothHand.x * 0.005);
                    particles.rotation.x -= (state.smoothHand.y * 0.005);
                }
            } else {
                state.gesture = "IDLE (WAITING)";
                // Auto Rotate
                particles.rotation.y += 0.002;
            }

            // Update HUD
            document.getElementById('active-gesture').innerText = state.gesture;

            // 3. Physics & Morph Loop
            const pal = CONFIG.colorPalettes[state.paletteIdx];
            
            for(let i=0; i<CONFIG.count; i++) {
                const idx = i*3;
                let tx = targets[idx];
                let ty = targets[idx+1];
                let tz = targets[idx+2];

                // MODIFIER: STRETCH
                tx *= stretchFactor;

                // MODIFIER: SPLIT (Peace Sign)
                if (splitMode) {
                    if (ty > 0) ty += 5; else ty -= 5;
                }

                // MODIFIER: GRAVITY (Black Hole)
                if (gravityCenter) {
                    tx = (tx * 0.9) + (gravityCenter.x * 0.1);
                    ty = (ty * 0.9) + (gravityCenter.y * 0.1);
                    tz = (tz * 0.9);
                }

                // MODIFIER: CHAOS (Fist/Voice)
                if (chaos > 0) {
                    tx += (Math.random()-0.5)*chaos;
                    ty += (Math.random()-0.5)*chaos;
                    tz += (Math.random()-0.5)*chaos;
                }

                // Apply Audio Color Pulse
                // Mix base color with audio heat
                const baseC = pal[i % 3];
                if (audioFactor > 0.3 && i % 10 === 0) {
                    colors[idx] = 1; colors[idx+1] = 1; colors[idx+2] = 1; // Flash white
                } else {
                    colors[idx] += (baseC.r - colors[idx]) * 0.05;
                    colors[idx+1] += (baseC.g - colors[idx+1]) * 0.05;
                    colors[idx+2] += (baseC.b - colors[idx+2]) * 0.05;
                }

                // PHYSICS INTEGRATION (Lerp)
                positions[idx] += (tx - positions[idx]) * 0.05;
                positions[idx+1] += (ty - positions[idx+1]) * 0.05;
                positions[idx+2] += (tz - positions[idx+2]) * 0.05;
            }

            particles.geometry.attributes.position.needsUpdate = true;
            particles.geometry.attributes.color.needsUpdate = true;
            renderer.render(scene, camera);
        }

        // --- MEDIAPIPE ---
        const videoElement = document.getElementById('video-input');
        
        function onResults(results) {
            document.getElementById('loader').style.display = 'none';
            document.getElementById('intro').style.display = 'none';
            
            state.hands = [];

            if (results.multiHandLandmarks) {
                document.getElementById('status-track').innerText = "LOCKED (" + results.multiHandLandmarks.length + ")";
                document.getElementById('status-track').style.backgroundColor = "#00ffcc";
                document.getElementById('status-track').style.color = "#000";

                for (const landmarks of results.multiHandLandmarks) {
                    // Coordinates map (0-1) -> World (-20 to 20)
                    const x = (landmarks[8].x - 0.5) * -40; 
                    const y = (landmarks[8].y - 0.5) * -30;
                    
                    // Gesture Analysis
                    // Is Fist? (Tips 8, 12, 16, 20 below Knuckles 5, 9, 13, 17)
                    // Simplified: Distance thumb-index is small AND index-pinky is small
                    const thumbTip = landmarks[4];
                    const indexTip = landmarks[8];
                    const middleTip = landmarks[12];
                    const ringTip = landmarks[16];
                    const pinkyTip = landmarks[20];
                    const wrist = landmarks[0];

                    const dThumbIndex = Math.hypot(thumbTip.x-indexTip.x, thumbTip.y-indexTip.y);
                    const dIndexWrist = Math.hypot(indexTip.x-wrist.x, indexTip.y-wrist.y);
                    const dPinkyWrist = Math.hypot(pinkyTip.x-wrist.x, pinkyTip.y-wrist.y);
                    
                    const isFist = dIndexWrist < 0.2 && dPinkyWrist < 0.2;
                    const isPeace = !isFist && landmarks[8].y < landmarks[6].y && landmarks[12].y < landmarks[10].y && landmarks[16].y > landmarks[14].y;

                    state.hands.push({
                        x: x, y: y,
                        rawX: (landmarks[8].x - 0.5) * -1, rawY: (landmarks[8].y - 0.5) * -1,
                        isFist: isFist,
                        isPeace: isPeace,
                        indexOpen: !isFist
                    });
                }
            } else {
                 document.getElementById('status-track').innerText = "SEARCHING...";
                 document.getElementById('status-track').style.backgroundColor = "#555";
                 document.getElementById('status-track').style.color = "#aaa";
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({
            maxNumHands: 2, // ENABLE 2 HANDS
            modelComplexity: 1,
            minDetectionConfidence: 0.6,
            minTrackingConfidence: 0.6
        });
        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        });

        function startSystem() {
            document.getElementById('loader').style.display = 'block';
            cameraUtils.start();
            initAudio();
            animate();
        }

        // SWIPE DETECTION (Simple)
        let lastX = 0;
        setInterval(() => {
            if(state.hands.length > 0) {
                const currX = state.hands[0].x;
                const diff = currX - lastX;
                if (diff > 5) { // Fast Swipe Right
                    state.shapeIdx = (state.shapeIdx + 1) % shapes.length;
                    updateTargets();
                }
                lastX = currX;
            }
        }, 300);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
